<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 wykład 7: Rozkłady stacjonarne, zaburzenia ruchu Browna | SMUO_wyklad8.knit</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="1 wykład 7: Rozkłady stacjonarne, zaburzenia ruchu Browna | SMUO_wyklad8.knit" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 wykład 7: Rozkłady stacjonarne, zaburzenia ruchu Browna | SMUO_wyklad8.knit" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>



<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="test.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="wyklad8/smso_2024_wyklad8.html"><a href="#wyk%C5%82ad-7-rozk%C5%82ady-stacjonarne-zaburzenia-ruchu-browna"><i class="fa fa-check"></i><b>1</b> wykład 7: Rozkłady stacjonarne, zaburzenia ruchu Browna</a>
<ul>
<li class="chapter" data-level="1.1" data-path="wyklad8/smso_2024_wyklad8.html"><a href="#motywacje"><i class="fa fa-check"></i><b>1.1</b> Motywacje</a></li>
<li class="chapter" data-level="1.2" data-path="wyklad8/smso_2024_wyklad8.html"><a href="#systemy-spinowe"><i class="fa fa-check"></i><b>1.2</b> Systemy spinowe</a></li>
<li class="chapter" data-level="1.3" data-path="wyklad8/smso_2024_wyklad8.html"><a href="#dygresja-analityczna"><i class="fa fa-check"></i><b>1.3</b> Dygresja analityczna</a></li>
<li class="chapter" data-level="1.4" data-path="wyklad8/smso_2024_wyklad8.html"><a href="#konstrukcja-system%C3%B3w-spinowych"><i class="fa fa-check"></i><b>1.4</b> Konstrukcja systemów spinowych</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="wykład-7-rozkłady-stacjonarne-zaburzenia-ruchu-browna" class="section level1 hasAnchor" number="1">
<h1><span class="header-section-number">1</span> wykład 7: Rozkłady stacjonarne, zaburzenia ruchu Browna<a href="#wyk%C5%82ad-7-rozk%C5%82ady-stacjonarne-zaburzenia-ruchu-browna" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="motywacje" class="section level2 hasAnchor" number="1.1">
<h2><span class="header-section-number">1.1</span> Motywacje<a href="#motywacje" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Aby umotywować nasze przyszłe działania przedyskutujemy kilka
przykładów. Od tej pory niech <span class="math inline">\(G =(V, E)\)</span> będzie przeliczalnym grafem
prostym o ograniczonym stopniu. Dokładniej zakładać będziemy, że zbiór
jego wierzchołków <span class="math inline">\(V\)</span> jest skończony bądź przeliczalny oraz, że
<span class="math display">\[\sup_{x \in V} \mathrm{deg}(x) &lt;\infty.\]</span> Rozważmy następujące trzy
procesy na <span class="math inline">\(G\)</span>.</p>
<div class="example">
<p><span id="exm:unlabeled-div-1" class="example"><strong>Przykład 1.1  </strong></span>(Voter model). Przypuśćmy, że na <span class="math inline">\(G\)</span> są dwie wzajemnie
zwalczające się frakcje (można myśleć o republikanach i demokratach). Na
każdy wierzchołek jednej frakcji oddziałują (poprzez indoktrynację)
sąsiedzi z frakcji przeciwnej. Na skutek czego niektóre wierzchołki
zmieniają frakcję na przeciwną. Dokładniej każdy <span class="math inline">\(x \in V\)</span> zmienia
frakcję w intensywnością równą
<span class="math display">\[c(x) = \# \{ y \in V \: \: x \sim y, \: \mbox{$y$ jest z innej frakcji niż $x$} \}.\]</span>
Jest to równoważne z następującym opisem.</p>
<ul>
<li><p>Dla każdej pary sąsiednich wierzchołków <span class="math inline">\(x\sim y\)</span> pochodzących z
różnych frakcji losujemy niezależnie dwie liczby <span class="math inline">\(E_{x\to y}\)</span> oraz
<span class="math inline">\(E_{y\to x}\)</span> z rozkładu wykładniczego z parametrem jeden.
<span class="math inline">\(E_{x\to y}\)</span> interpretujemy jako czas, jaki potrzebuje <span class="math inline">\(x\)</span> aby
przekabacić <span class="math inline">\(y\)</span>.</p></li>
<li><p>W momencie, w którym którykolwiek z wierzchołków przeciągnie sąsiada
(powiedzmy <span class="math inline">\(y\)</span>) na swoją stronę, losujemy nowe wagi dla sąsiadów <span class="math inline">\(y\)</span>
(według nowego układu obu frakcji).</p></li>
</ul>
<p>Oczywiście powyższa, naiwna konstrukcja ma sens tylko, gdy graf <span class="math inline">\(G\)</span> jest
skończony. W przypadku grafów nieskończonych wymagana jest odpowiednia
konstrukcja, którą opiszemy niebawem.</p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-2" class="example"><strong>Przykład 1.2  </strong></span>(Contact process). Załóżmy, że na grafie <span class="math inline">\(G\)</span> panuje
epidemia. Niech <span class="math inline">\(\lambda &gt;0\)</span> będzie ustalonym parametrem. Proces rozwija
się według następujących zasad.</p>
<ul>
<li><p>Chore wierzchołki niezależnie zarażają swoich zdrowych sąsiadów z
czasem wykładniczym z parametrem <span class="math inline">\(\lambda\)</span>.</p></li>
<li><p>Chore wierzchołki zdrowieją niezależnie z czasem wykładniczym z
parametrem jeden.</p></li>
</ul>
<p>Ponownie powyższy opis ma sens jedynie w przypadku, gdy <span class="math inline">\(G\)</span> jest
skończony. Dla nieskończonych grafów <span class="math inline">\(G\)</span> będziemy posługiwać się
równoważną charakteryzacją</p>
<ul>
<li><p>Każdy chory wierzchołek zdrowieje z intensywnością <span class="math inline">\(1\)</span></p></li>
<li><p>Każdy zdrowy wierzchołek <span class="math inline">\(x\)</span> choruje z intensywnością
<span class="math display">\[\lambda \# \{ y\sim x \: : \: y \mbox{ chory}\}.\]</span></p></li>
</ul>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-3" class="example"><strong>Przykład 1.3  </strong></span>(Exclusion process). Rozważmy zjawisko migracji na grafie
<span class="math inline">\(G\)</span>. Załóżmy, że pewne wierzchołki <span class="math inline">\(G\)</span> są zajmowane przez osobników
ustalonego gatunku (przykładowo krowy). Każdy osobnik czeka niezależnie
wykładniczy czas z parametrem jeden, po czym podejmuje próbę
przemieszczenia się.</p>
<ul>
<li><p>Jeżeli osobnik zajmuje wierzchołek <span class="math inline">\(x \in V\)</span>, to losuje wierzchołek
<span class="math inline">\(y\)</span> z prawdopodobieństwem <span class="math inline">\(p(x,y)\)</span>.</p></li>
<li><p>Jeżeli wierzchołek <span class="math inline">\(y\)</span> nie jest zajęty, to osobnik przechodzi do
<span class="math inline">\(y\)</span>.</p></li>
</ul>
</div>
<p>W każdym z powyższych przykładów stan układu w chwili <span class="math inline">\(t\)</span> można
zakodować przy pomocy <span class="math inline">\(\eta_t \in \{ 0,1\}^V\)</span>. Okazuje się, że wówczas
<span class="math inline">\(\eta = (\eta_t)_{t \in \mathbb{R}_+}\)</span> staje się procesem Fellera. Aby
się o tym dokładnie przekonać musimy przeanalizować generatory
wynikające z przykładów.</p>
</div>
<div id="systemy-spinowe" class="section level2 hasAnchor" number="1.2">
<h2><span class="header-section-number">1.2</span> Systemy spinowe<a href="#systemy-spinowe" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Właściwością, która odróżnia systemy spinowe od innych procesów Fellera
na <span class="math inline">\(\{0,1\}^S\)</span>, jest to, że poszczególne przejścia obejmują tylko jedną
lokalizację. Niech <span class="math inline">\(c \colon V \times \{0,1\}^V \to \mathbb{R}_+\)</span> będzie
ograniczoną funkcją taką, że dla każdego <span class="math inline">\(x \in V\)</span>,
<span class="math inline">\(c(x, \cdot) \colon \{0,1\}^V \to \mathbb{R}_+\)</span> jest ciągła. <span class="math inline">\(c(x,\eta)\)</span>
interpretować będziemy jako intensywność, z jaką stan <span class="math inline">\(\eta\)</span> zmienia się
poprzez zmianę wartości w <span class="math inline">\(x\)</span>. Dla <span class="math inline">\(x \in V\)</span> oraz <span class="math inline">\(\eta \in \{0,1\}^V\)</span>
definiujemy <span class="math inline">\(\eta^{(x)} \in \{0,1\}^V\)</span> wzorem <span class="math display">\[\eta^{(x)}(y) = \left\{
    \begin{array}{cc} \eta(y), &amp; y \neq x \\ 1-\eta(x), &amp; y=x \end{array}\right..\]</span>
Dla <span class="math inline">\(f\)</span> pochodzącego z odpowiedniego podzbioru <span class="math inline">\(C_0(\{0,1\}^V)\)</span> chcemy
położyć
<span class="math display" id="eq:4-defL">\[\begin{equation}
    Lf(\eta) = \sum_{x\in V} c(x, \eta)\left[f\left(\eta^{(x)}\right) - f(\eta)\right].
\tag{1.1}
\end{equation}\]</span>
Okazuje się, że dokładne napisanie dziedziny jest problematyczne. Aby
obejść tę trudność rozważmy
<span class="math display" id="eq:4-defD">\[\begin{equation}
    D = \left\{ f \in C(\{0,1\}^V) : \|f\|_o := \sup_{\eta} \sum_x \left|f\left(\eta^{(x)}\right) - f(\eta)\right| &lt; \infty \right\}.
\tag{1.2}
\end{equation}\]</span></p>
<p>Naszym celem jest pokazanie, że zdefiniowanie <span class="math inline">\(L\)</span> na <span class="math inline">\(D\)</span> wystarcza do
zdefiniowania procesu.</p>
</div>
<div id="dygresja-analityczna" class="section level2 hasAnchor" number="1.3">
<h2><span class="header-section-number">1.3</span> Dygresja analityczna<a href="#dygresja-analityczna" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Generator infinitezymalny nie należy do najprostszych obiektów w teorii
procesów Fellera. Jednym z powodów jest konieczność uwzględnienia
dzieciny która, jak się już przekonaliśmy, ma istotny wpływ na kształt
generowanego procesu. Rzadko się jednak zdarza, że dziedzinę można
opisać jawnie. Dlatego często definiuje się proponowany generator na
wygodnej podprzestrzeni dziedziny, a następnie bierze się domknięcie.</p>
<div class="definition">
<p><span id="def:unlabeled-div-4" class="definition"><strong>Definicja 1.1  </strong></span>Operator liniowy <span class="math inline">\((L, \mathcal{D}(L))\)</span> na <span class="math inline">\(C_0(S)\)</span>
nazywany jest domkniętym, jeśli jego wykres
<span class="math display">\[\Gamma(L)=\{(f, Lf) : f \in D(L)\}\]</span> jest domkniętym podzbiorem
<span class="math inline">\(C_0(S) \times C_0(S)\)</span>.</p>
</div>
<p>Operator <span class="math inline">\(L\)</span> jest domknięty wtedy i tylko wtedy, gdy
<span class="math inline">\(f_n \in \mathcal{D}(L)\)</span> są takie, że <span class="math inline">\(f_n \to f\)</span> oraz <span class="math inline">\(Lf_n \to h\)</span>, to
<span class="math inline">\(f \in \mathcal{D}(L)\)</span> oraz <span class="math inline">\(h=Lf\)</span>.</p>
<div class="definition">
<p><span id="def:unlabeled-div-5" class="definition"><strong>Definicja 1.2  </strong></span>Operator liniowy <span class="math inline">\((L, \mathcal{D}(L))\)</span> nazywany jest
domykalnym, jeżeli domknięcie jego wykresu <span class="math inline">\(\Gamma(L)\)</span> jest wykresem
operatora liniowego. W takiej sytuacji definiujemy domknięcie
<span class="math inline">\(\overline{L}\)</span> operatora <span class="math inline">\(L\)</span> poprzez
<span class="math display">\[\Gamma \left( \overline{L} \right) = \overline{\Gamma(L)}.\]</span></p>
</div>
<p>Operator <span class="math inline">\(L\)</span> jest domykalny wtedy i tylko wtedy, gdy <span class="math inline">\(f_n \to 0\)</span> oraz
<span class="math inline">\(Lf_n \to h\)</span> implikują <span class="math inline">\(h=0\)</span>. Nie każdy operator liniowy ma domknięcie.
Na przykład, przypuśćmy, że <span class="math inline">\(S = [0, 1]\)</span> i
<span class="math display">\[\mathcal{D}(L) = \{ f \in C(S) : f&#39;(0) \text{ istnieje} \}
        \quad \text{i} \quad Lf(x) = f&#39;(0)x \text{ dla } f \in \mathcal{D}(L).\]</span>
Wtedy domknięcie wykresu <span class="math inline">\(L\)</span> nie jest wykresem operatora liniowego.
Jednakże w kontekście
Definicji <a href="#def:3-12"><strong>??</strong></a> taka sytuacja nie występuje.</p>
<div class="proposition">
<p><span id="prp:3.30" class="proposition"><strong>(#prp:3.30) </strong></span>Niech <span class="math inline">\((L, \mathcal{D}(L))\)</span> będzie operatorem liniowym na
<span class="math inline">\(C_0(S)\)</span>.</p>
<ul>
<li><p>Przypuśćmy, że <span class="math inline">\(L\)</span> spełnia (GI1)-(GI3) z
Definicji <a href="#def:3-12"><strong>??</strong></a>. Wtedy <span class="math inline">\(L\)</span> jest domykalny, a jego domknięcie
spełnia (GI1)-(GI3).</p></li>
<li><p>Jeśli <span class="math inline">\(L\)</span> spełnia (GI1)- (GI4) z
Definicji <a href="#def:3-12"><strong>??</strong></a>, wtedy <span class="math inline">\(L\)</span> jest domknięty.</p></li>
<li><p>Jeśli <span class="math inline">\(L\)</span> spełnia (GI3) i (GI4), to <span class="math display">\[\mathcal{R}(I - \lambda L)
                    = C_0(S) \quad \text{dla każdego } \lambda &gt; 0.\]</span></p></li>
<li><p>Jeśli <span class="math inline">\(L\)</span> jest domknięty i spełnia (GI3), to
<span class="math inline">\(\mathcal{R}(I - \lambda L)\)</span> jest domkniętym podzbiorem <span class="math inline">\(C_0(S)\)</span>.</p></li>
</ul>
</div>
<div class="proof">
<p><span id="unlabeled-div-6" class="proof"><em>Proof</em>. </span>Dla pierwszego stwierdzenia, musimy udowodnić, że
<span class="math inline">\(f_n \in \mathcal{D}(L), f_n \to 0\)</span>, oraz <span class="math inline">\(Lf_n \to h\)</span> implikuje
<span class="math inline">\(h = 0\)</span>. Aby to zrobić, wybierzmy <span class="math inline">\(g \in \mathcal{D}(L)\)</span>. Korzystając z
<a href="#eq:3-12">(<strong>??</strong>)</a>,
<span class="math display">\[\|(I - \lambda L)(f_n + \lambda g)\|
            \geq \|f_n + \lambda g\|,
            \quad \lambda &gt; 0.\]</span> Biorąc <span class="math inline">\(n \to \infty\)</span> i następnie
dzieląc przez <span class="math inline">\(\lambda\)</span>, dostajemy
<span class="math display">\[\|g - h - \lambda Lg\| \geq \|g\|.\]</span> Jeżeli teraz wybierzemy
<span class="math inline">\(\lambda \to 0\)</span>, to otrzymamy <span class="math display">\[\| g-h \| \geq \|g\|.\]</span> Skoro
<span class="math inline">\(g\in \mathcal{D}(L)\)</span> jest wzięte z gęstego zbioru otrzymujemy <span class="math inline">\(h = 0\)</span>.
Domknięcie <span class="math inline">\(\overline{L}\)</span> spełnia własności (GI1) i (GI2), ponieważ jest
rozszerzeniem <span class="math inline">\(L\)</span>. Aby sprawdzić, czy spełnia własność (GI3),
przypuśćmy, że <span class="math inline">\(f \in \mathcal{D}(\overline{L}), \lambda \geq 0\)</span> i
<span class="math inline">\(f - \lambda \overline{L}f = g\)</span>. Przez definicję domknięcia, istnieją
<span class="math inline">\(f_n \in \mathcal{D}(L)\)</span>, takie że <span class="math inline">\(f_n \to f\)</span> i
<span class="math inline">\(Lf_n \to \overline{L}f\)</span>. Przez własność (GI3) dla <span class="math inline">\(L\)</span>,
<span class="math display">\[\inf_{x \in S} f_n(x) \geq \inf_{x \in S} g_n(x),\]</span> gdzie
<span class="math inline">\(g_n = f_n - \lambda Lf_n\)</span>. Teraz niech <span class="math inline">\(n \to \infty\)</span>. Dostajemy
<span class="math display">\[\inf_{x \in S} f(x) \geq \inf_{x \in S} g(x),\]</span> czyli własność <span class="math inline">\((GI3)\)</span>
dla <span class="math inline">\(\overline{L}\)</span>.</p>
<p>Dla dowodu drugiej części faktu, niech <span class="math inline">\(\overline{L}\)</span> będzie domknięciem
<span class="math inline">\(L\)</span>. Jeśli <span class="math inline">\(f \in \mathcal{D}(\overline{L})\)</span> i <span class="math inline">\(\lambda &gt; 0\)</span> jest małe,
przez własność (GI4) istnieje <span class="math inline">\(h \in \mathcal{D}(L)\)</span> takie że
<span class="math display" id="eq:3-25">\[\begin{equation}
            h - \lambda Lh = f - \lambda \overline{L}f,\tag{1.3}\end{equation}\]</span> czyli
<span class="math inline">\((h - f) - \lambda \overline{L}(h - f) = 0\)</span>. Z <a href="#eq:3-12">(<strong>??</strong>)</a>,
<span class="math inline">\(h = f\)</span>, a wtedy <span class="math inline">\(\overline{L}f = Lh\)</span> z <a href="#eq:3-25">(1.3)</a>.
Więc, <span class="math inline">\(\overline{L} = L\)</span> zgodnie z tezą.</p>
<p>Przechodząc do trzeciego stwierdzenia, wystarczy sprawdzić, że dla
<span class="math inline">\(0 &lt; \lambda &lt; \gamma\)</span> warunek <span class="math inline">\(\mathcal{R}(I - \lambda L) = C_0(S)\)</span>
implikuje <span class="math inline">\(\mathcal{R}(I - \gamma L) = C_0(S)\)</span>. Załóżmy, że
<span class="math inline">\(g \in C_0(S)\)</span>, i zdefiniujmy <span class="math inline">\(\Gamma : C(S) \to \mathcal{D}(L)\)</span> przez
<span class="math display">\[\gamma \Gamma h
        = \lambda (I - \lambda L)^{-1} g + (\gamma - \lambda)(I - \lambda L)^{-1} h.\]</span>
Definicja ta jest poprawna, ponieważ założyliśmy
<span class="math inline">\(\mathcal{R}(I - \lambda L) = C_0(S)\)</span>. Mamy
<span class="math display">\[\gamma \| \Gamma h_1 - \Gamma h_2 \|
        = (\gamma - \lambda) \| (I - \mathcal{L})^{-1} (h_1 - h_2) \|
        \leq (\gamma - \lambda) \| h_1 - h_2 \|.\]</span> Stąd <span class="math inline">\(\Gamma\)</span> jest
odwzorowaniem zwężającym, a więc z Twierdzenia Banacha o punkcie stałym
posiada jedyny punkt stały <span class="math inline">\(f\)</span>. Wówczas <span class="math inline">\(f \in \mathcal{D}(L)\)</span> oraz
<span class="math display">\[\gamma (I - \lambda \mathcal{L}) f
        = \lambda g + (\gamma - \lambda) f.\]</span> Co można przekształcić do
postaci <span class="math inline">\(f - \gamma L f = g\)</span>. Czyli <span class="math inline">\(g \in \mathcal{R}(I - \gamma L)\)</span>,
co należało uzasadnić.</p>
<p>Aby udowodnić ostatnie stwierdzenie, załóżmy, że
<span class="math inline">\(g_n \in \mathcal{R}(I - \lambda L)\)</span> i <span class="math inline">\(g_n \to g\)</span>. Wtedy możemy
zdefiniować <span class="math inline">\(f_n \in \mathcal{D}(L)\)</span> przez <span class="math display">\[\label{eq:3.26}
        f_n - \lambda L f_n = g_n.\]</span> Wówczas
<span class="math display">\[(f_n - f_m) - \lambda L (f_n - f_m) = g_n - g_m,\]</span> a zatem
<span class="math inline">\(\| f_n - f_m \| \leq \| g_n - g_m \|\)</span>. Ponieważ
<span class="math inline">\(\{g_n\}_{n \in \mathbb{N}}\)</span> jest ciągiem Cauchy’ego, to
<span class="math inline">\(\{f_n\}_{n \in \mathbb{N}}\)</span> również. Niech
<span class="math inline">\(f = \lim_{n \to \infty} f_n\)</span>. Ponieważ <span class="math inline">\(f_n \to f\)</span> i <span class="math inline">\(g_n \to g\)</span>, to z <a href="#eq:3-26">(<strong>??</strong>)</a>
wynika, że <span class="math inline">\(\lim_{n \to \infty} L f_n\)</span> również istnieje. Ponieważ <span class="math inline">\(L\)</span>
jest domknięte, granicą jest <span class="math inline">\(L f\)</span>, a więc <span class="math inline">\(f - \lambda L f = g\)</span>, co
oznacza, że <span class="math inline">\(g \in \mathcal{R}(I - \lambda L)\)</span>, czego należało
dowieść.</p>
</div>
</div>
<div id="konstrukcja-systemów-spinowych" class="section level2 hasAnchor" number="1.4">
<h2><span class="header-section-number">1.4</span> Konstrukcja systemów spinowych<a href="#konstrukcja-system%C3%B3w-spinowych" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Naszym pierwszym celem jest znalezienie naturalnych warunków na
<span class="math inline">\(c(x, \eta)\)</span>, które gwarantują, że domknięcie <span class="math inline">\((L,D)\)</span>, gdzie <span class="math inline">\(L\)</span> i <span class="math inline">\(D\)</span>
są dane odpowiednio
przez <a href="#eq:4-defL">(1.1)</a>
oraz <a href="#eq:4-defD">(1.2)</a> jest operatorem infinitezymalnym. Warunki (GI1),
(GI2), (GI3) i (GI5) są łatwe do sprawdzenia i nie wymagają dodatkowych
założeń. Prawdziwym wyzwaniem jest (GI4).</p>
<p>Dla warunku (GI2), używamy twierdzenia Stone’a-Weierstrassa: <span class="math inline">\(D\)</span> jest
algebrą funkcji ciągłych na zbiorze zwartym, która rozdziela punkty.
Istotnie, dla <span class="math inline">\(\eta \neq \zeta\)</span> istnieje <span class="math inline">\(x \in S\)</span> takie, że
<span class="math inline">\(\eta(x) \neq \zeta(x)\)</span>. Funkcja <span class="math inline">\(f(\xi) = \xi(x)\)</span> rozdziela <span class="math inline">\(\eta\)</span> i
<span class="math inline">\(\zeta\)</span>. Algebra <span class="math inline">\(D\)</span> zawiera funkcje stałe, więc
<span class="math inline">\(\overline{D} = C(\{0,1\}^V)\)</span>.</p>
<p>Dla (GI3), załóżmy <span class="math inline">\(f \in D\)</span>, <span class="math inline">\(\lambda \geq 0\)</span>, oraz
<span class="math inline">\(f - \lambda Lf = g\)</span>. Ponieważ <span class="math inline">\(\{0,1\}^V\)</span> jest zbiorem zwartym i <span class="math inline">\(f\)</span>
jest ciągła, istnieje takie <span class="math inline">\(\eta\)</span>, dla którego <span class="math inline">\(f\)</span> osiąga swoje
minimum. Wtedy <span class="math inline">\(Lf(\eta) \geq 0\)</span>, więc <span class="math display">\[\min_\zeta f(\zeta)
        = f(\eta) \geq g(\eta)
        \geq \min_\zeta g(\zeta).\]</span></p>
<p>Warunek (GI5) wynika z faktu, że <span class="math inline">\(1 \in D\)</span> oraz <span class="math inline">\(L1 = 0\)</span>.</p>
<p>Aby sprawdzić (GI4) musimy wyprowadzić ograniczenie dla rozwiązań
równania <span class="math inline">\(f - \lambda Lf = g\)</span>. Niech
<span class="math display">\[\epsilon = \inf_{u, \eta} [c(u, \eta) + c(u, \eta_u)] \quad \text{oraz}
        \quad \gamma(x, u) = \sup_\eta |c(x, \eta_u) - c(x, \eta)|.\]</span>
Zauważmy, że <span class="math inline">\(\gamma(x,u)\)</span> mierzy stopień, w jakim intensywność zmiany w
miejscu <span class="math inline">\(x\)</span> zależy od konfiguracji w miejscu <span class="math inline">\(u\)</span>. Niech <span class="math inline">\(\ell_1(V)\)</span>
będzie przestrzenią Banacha funkcji <span class="math inline">\(\alpha : V \to \mathbb{R}\)</span>, które
spełniają <span class="math display">\[||\alpha|| := \sum_x |\alpha(x)| &lt; \infty.\]</span> Macierz
<span class="math inline">\(\gamma\)</span> definiuje operator <span class="math inline">\(\Gamma\)</span> na <span class="math inline">\(\ell_1(S)\)</span> przez
<span class="math display">\[\Gamma \alpha(u) = \sum_{x: x \neq u} \alpha(x) \gamma(x, u).\]</span>
Operator ten jest dobrze zdefiniowany i ograniczony, pod warunkiem że
<span class="math display">\[M := \sup_x \sum_{u: u \neq x} \gamma(x, u) &lt; \infty,\]</span> a wtedy
<span class="math inline">\(||\Gamma|| = M\)</span>.</p>
<p>Dla <span class="math inline">\(f \in C(\{0,1\}^V)\)</span> i <span class="math inline">\(x \in S\)</span>, niech
<span class="math display">\[\Delta f(x) = \sup_{\eta} \left|f\left(\eta^{(x)}\right) - f(\eta)\right|.\]</span>
Wtedy <span class="math inline">\(\|f\|_o = ||\Delta f||_{l_1(V)}\)</span>. Oto oszacowanie, którego
potrzebujemy.</p>
<div class="proposition">
<p><span id="prp:4.2" class="proposition"><strong>(#prp:4.2) </strong></span>Załóżmy, że spełniony jest jeden z warunków</p>
<ul>
<li><p><span class="math inline">\(f \in D\)</span>,</p></li>
<li><p><span class="math inline">\(f\)</span> jest ciągła i \begin{equation}
c(x, )
x V.(#eq:4.3)end{equation}</p></li>
</ul>
<p>Wówczas jeśli <span class="math inline">\(f - \lambda Lf = g \in D\)</span>, <span class="math inline">\(\lambda &gt; 0\)</span>, oraz
<span class="math inline">\(\lambda M &lt; 1 + \lambda \epsilon\)</span>, to <span class="math display">\[
        \Delta f \leq \left[ (1 + \lambda \epsilon)I - \lambda \Gamma \right]^{-1} \Delta g,(\#eq:4.4)\]</span>
gdzie nierówność zachodzi współrzędna po współrzędnej, a odwrotność jest
zdefiniowana przez nieskończony szereg <span class="math display">\[\begin{equation}
        \left[ (1 + \lambda \epsilon)I - \lambda \Gamma \right]^{-1} \alpha
        = \frac{1}{1 + \lambda \epsilon} \sum_{k=0}^{\infty}
        \left( \frac{\lambda}{1 + \lambda \epsilon} \right)^k \Gamma^k \alpha.(\#eq:4.5)\end{equation}\]</span></p>
</div>
<div class="proof">
<p><span id="unlabeled-div-7" class="proof"><em>Proof</em>. </span>Zauważmy, że szereg w @ref(eq:4.5) jest
zbieżny dla <span class="math inline">\(\alpha \in \ell_1(V)\)</span> na mocy założenia
<span class="math inline">\(\lambda M &lt; 1 + \lambda \epsilon\)</span>. Pisząc <span class="math inline">\(f - \lambda Lf = g\)</span> w
punktach <span class="math inline">\(\eta\)</span> oraz <span class="math inline">\(\eta^{(u)}\)</span>, odejmując i zauważając że
<span class="math inline">\((\eta^{(u)})^{(u)} = \eta\)</span>, otrzymujemy <span class="math display">\[\begin{multline}
        [f(\eta^{(u)}) - f(\eta)][1 + \lambda c(u, \eta) + \lambda c(u, \eta^{(u)})]
        = [g(\eta^{(u)}) - g(\eta)]\\
        + \lambda \sum_{x:x \neq u} \left\{ c(x, \eta^{(u)}) [f((\eta^{(u)})^{(x)})
        - f(\eta^{(u)})] - c(x, \eta)[f(\eta^{(x)}) - f(\eta)] \right\}.
(\#eq:4.6)
\end{multline}\]</span> Ponieważ wartości <span class="math inline">\(f(\eta^{(u)}) - f(\eta)\)</span>, gdy <span class="math inline">\(\eta\)</span>
zmienia się a <span class="math inline">\(u\)</span> jest ustalone, tworzą zbiór symetryczny, a ta różnica
jest funkcją ciągłą <span class="math inline">\(\eta\)</span>, dla każdego <span class="math inline">\(u\)</span> istnieje takie <span class="math inline">\(\eta\)</span>, że
<span class="math display">\[f(\eta^{(u)}) - f(\eta) = \sup_{\zeta} |f(\zeta^{(u)}) - f(\zeta)| = \Delta f(u).\]</span>
Stąd, <span class="math display">\[f(\zeta^{(u)}) - f(\zeta) \leq f(\eta^{(u)}) - f(\eta)\]</span> dla
każdej <span class="math inline">\(\zeta\)</span>. Stosując to dla <span class="math inline">\(\zeta = \eta^{(x)}\)</span> i przekształcając,
otrzymujemy <span class="math display">\[f((\eta^{(u)})^{(x)}) - f(\eta^{(u)})
        = f((\eta^{(x)})^{(u)}) - f(\eta^{(u)}) \leq f(\eta^{(x)}) - f(\eta),\]</span>
Używając tej nierówności w @ref(eq:4.6),
<span class="math display">\[\begin{multline}

        \Delta f(u)(1 + \lambda \epsilon) \leq
        \Delta f(u)[1 + \lambda c(u, \eta) + \lambda c(u, \eta^{(u)})] \\
        \leq \Delta g(u) + \lambda \sum_{x:x \neq u}
        \left[ c(x, \eta^{(u)}) - c(x, \eta) \right] [f(\eta^{(x)}) - f(\eta)]
        \\ \leq \Delta g(u) + \lambda \sum_{x:x \neq u} \gamma(x,u) \Delta f(x).
(\#eq:4.7)
\end{multline}\]</span>
Jeśli @ref(eq:4.3) zachodzi, to tylko skończona liczba wyrazów po
prawej stronie jest niezerowa, więc <span class="math inline">\(\|\Delta_f\|_1 = \|f\|_o &lt;\infty\)</span>.
Zastem przy któregokolwiek z założeń faktu, <span class="math inline">\(f \in D\)</span>. Dlatego
@ref(eq:4.7) można
zapisać jako
<span class="math display">\[(1 + \lambda \epsilon) \Delta f \leq \Delta g + \lambda \Gamma \Delta f.\]</span>
Iteracja tej nierówności prowadzi to do
<span class="math display">\[\Delta f \leq \frac{1}{1 + \lambda \epsilon}
        \sum_{k=0}^{n} \left( \frac{\lambda}{1 + \lambda \epsilon} \right)^k
        \Gamma^k \Delta g + \left( \frac{\lambda}{1 + \lambda \epsilon} \right)^{n+1}
        \Gamma^{n+1} \Delta f.\]</span> Jeżeli rozważymy teraz <span class="math inline">\(n \to \infty\)</span>,
dostaniemy @ref(eq:4.4).</p>
</div>
<div class="theorem">
<p><span id="thm:4.3" class="theorem"><strong>(#thm:4.3) </strong></span>Załóżmy, że <span class="math inline">\(M &lt; \infty\)</span>. Wtedy <span class="math inline">\(\overline{L}\)</span> jest
generatorem infinitezymalnym półgrupy Fellera
<span class="math inline">\(T=(T(t))_{t \in \mathbb{R}_+}\)</span>. Ponadto,
<span class="math display">\[\begin{equation}
        \Delta T(t)f \leq e^{-t \epsilon} e^{t \Gamma} \Delta f.
(\#eq:4.8)
\end{equation}\]</span>
W szczególności, jeśli <span class="math inline">\(f \in D\)</span>, to <span class="math inline">\(T_tf \in D\)</span> oraz
<span class="math display">\[\begin{equation}
        \|T(t)f\|_o \leq e^{(M - \epsilon)t} \|f\|.
(\#eq:4.9)
\end{equation}\]</span></p>
</div>
<div class="proof">
<p><span id="unlabeled-div-8" class="proof"><em>Proof</em>. </span>Własności (GI1), (GI2), (GI3) i (GI5) z
Definicji <a href="#defn:3-12"><strong>??</strong></a> zachodzą dla <span class="math inline">\((L, D)\)</span> są i są dziedziczone przez
<span class="math inline">\(\overline{L}\)</span> z Faktu @ref(prp:3.30). Aby sprawdzić warunek (GI4) weźmy wstępujący ciąg
<span class="math inline">\(V_n\subseteq V\)</span> taki, że <span class="math inline">\(\bigcup_nV_n=V\)</span>. Niech
<span class="math display">\[\begin{equation}
        L_n f(\eta) =
        \sum_{x \in V_n} c(x, \eta) [f(\eta_x) - f(\eta)],
        \quad f \in C(\{0,1\}^V).
(\#eq:4.10)
\end{equation}\]</span>
To jest generator dla systemu
spinowego, w którym współrzędne <span class="math display">\[(\eta_t(x) : x \notin V_n)\]</span> są stałe
w czasie. Ponieważ <span class="math inline">\(L_n\)</span> jest ograniczonym generatorem, spełnia
<span class="math display">\[\mathcal{R}(I - \lambda L_n) = C(\{0,1\}^V)\]</span> dla wszystkich
<span class="math inline">\(\lambda &gt; 0\)</span>. Dla <span class="math inline">\(g \in D\)</span>, możemy zdefiniować <span class="math inline">\(f_n \in C(\{0,1\}^V)\)</span>
przez <span class="math inline">\(f_n - \lambda L_n f_n = g\)</span>. Ponieważ <span class="math inline">\(L_n\)</span> spełnia @ref(eq:4.3), jeśli
<span class="math inline">\(\lambda\)</span> jest wystarczająco małe, tak że
<span class="math inline">\(\lambda M &lt; 1 + \lambda \epsilon\)</span>, wtedy <span class="math inline">\(f_n \in D\)</span> zgodnie z
Faktem @ref(prp:4.2). W
związku z tym możemy położyć
<span class="math display">\[g_n = f_n - \lambda L f_n \in \mathcal{R}(I - \lambda L).\]</span> Niech
<span class="math inline">\(K = \sup_{x, \eta} c(x, \eta) &lt;\infty\)</span>, wtedy z
Faktu @ref(prp:4.2)
<span class="math display">\[\begin{multline}
        \|g_n - g\|
        = \lambda ||(L - L_n) f_n||
        \leq \lambda K \sum_{x \notin V_n} \Delta f_n(x)\\
        \leq \lambda K \sum_{x \notin V_n}
        \left[ (1 + \lambda \epsilon)I - \lambda \Gamma \right]^{-1} \Delta g(x).
(\#eq:4.11)
\end{multline}\]</span> Ponieważ <span class="math inline">\(\Delta g \in \ell_1(V)\)</span>, prawa strona
@ref(eq:4.11) dąży
do zera, gdy <span class="math inline">\(n \to \infty\)</span>, więc <span class="math inline">\(g_n \to g\)</span>. Stąd
<span class="math inline">\(g \in \mathcal{R}(I - \lambda L)\)</span>, więc wnioskujemy, że
<span class="math inline">\(D \subseteq \mathcal{R}(I - \lambda L)\)</span>. Ponieważ <span class="math inline">\(D\)</span> jest gęste w
<span class="math inline">\(C(\{0,1\}^V)\)</span>, widzimy, że <span class="math inline">\(\mathcal{R}(I - \lambda L)\)</span> jest również
gęste. Zatem <span class="math display">\[\mathcal{R}(I - \lambda \overline{L}) = C(\{0,1\}^V)\]</span>
zgodnie z Faktem @ref(prp:3.30). To kończy weryfikację, że <span class="math inline">\(\overline{L}\)</span> jest
generatorem infinitezymalnym.</p>
<p>Przechodząc do drugiego stwierdzenia, zapiszmy
@ref(eq:4.4) jako
<span class="math display">\[\Delta_{(I - \lambda L)^{-1}} g
        \leq \left[ (1 + \lambda \epsilon)I - \lambda \Gamma \right]^{-1} \Delta g,\]</span>
a następnie iterujmy, aby uzyskać
<span class="math display">\[\Delta_{(I - \frac{t}{n} L)^{-1}} g \leq
        \left[ \left( 1 + \frac{t}{n} \epsilon \right) I - \frac{t}{n} \Gamma \right]^{-n}
        \Delta g.\]</span> Przechodząc do granicy otrzymujemy
@ref(eq:4.8).</p>
</div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
